

def logic_func(*args):
	arg=[]

	for val in args:
		arg.append(val)
	if arg[0]=='AND':
		outp=arg[1] & arg[2]
	elif arg[0]=='OR':
		outp=arg[1] | arg[2]
	elif arg[0]=='XOR':
		outp=arg[1] ^ arg[2]
	elif arg[0]=='NAND':
		outp=(~(arg[1] & arg[2]))%2
	elif arg[0]=='NOR':
		outp=(~(arg[1] | arg[2]))%2
	elif arg[0]=='XNOR':
		outp=(~(arg[1] ^ arg[2]))%2
	elif arg[0]=='CHAO':
		x=2*arg[2]+arg[1]
		y=arg[3][x]
		outp=int(y)


	return outp
def mixed_logic_solver(char_file,fnetlist,inpname,inpval,keyname,keyval,outpname):
	#inputs
	'''
	inpname=['a','b','ci'] #test input name
	inpval=[1,0,0] #test input val
	keyname=['k1','k2','k3','k4','k5','k6','k7'] # key name for chaos gate
	keyval=[]
	'''
	#characterization data
	#char_chao contains the functions generated by the chaos gates
	char_chao=[]
	with open(char_file) as f_chao:
		for line in f_chao:
			count=0
			for word in line.split(','):
					#if count==1: #for new format of char_file Sabuj
					if count==5: #for old format of char file

						char_chao.append(int(word))
					count=count+1
	
	#print(char_chao[630:640])
	#netlist file parsing for spice
	#fnetlist="test.scp"

	netname=[] # list of all nets in the netlist
	netarray=[] # 2D list for gate description
	with open(fnetlist) as fnet:
		for line in fnet:
			'''
			line=line.replace(" ","")
			line=line.strip("\n")
			'''
			count=0
			temp=[]
			for word in line.split():
				#print(word)
				temp.append(word)
				if count!=0:
					if word not in netname:
						netname.append(word)
				count=count+1
			netarray.append(temp)

	#print(netarray)
	#print(netname)

	inpdict={}
	keydict={}
	#creating dictionary for input net name and value
	for i in range(0,len(inpname)):
		inpdict[inpname[i]]=inpval[i]
	#creating dictionary for key net name and value for CHAO gate
	for i in range(0,len(keyname)):
		keydict[keyname[i]]=keyval[i]

	netval={} #dictionary for keeping the value of each net
	netstatus={} #dictionary for keeping the update status (valid/invalid) of each net
	for i in range(0,len(netname)):

		#initializing value of each net
		if netname[i] in inpname:
			netval[netname[i]]=inpdict[netname[i]]
		else:
			netval[netname[i]]=0
		#print(netval)
		#initializing status of each net
		if netname[i] in inpname:
			netstatus[netname[i]]=1
		else:
			netstatus[netname[i]]=0

	#print(netval)
	#print(netstatus)

	#solver
	#iterating each gate
	i=0
	while (i<len(netarray)):
		gate_name=netarray[i][0]
		o_p=netarray[i][1]
		i_p1=netarray[i][2]
		i_p2=netarray[i][3]
		#print(i)
		if gate_name=='CHAO':
			key=keydict[netarray[i][4]]
			#print(key)
		#print(key)
		#print(i)
		#print(gate_name)
		#print(i_p1)
		#print(i_p2)
		#if the inputs of the gate are evaluated yet
		if (netstatus[i_p1]==1)&(netstatus[i_p2]==1):
			#print(True)
			#print(o_p)
			if gate_name=='CHAO':
				#print("key")
				#print (key)
				#print(char_chao[key-1])
				#print(key)
				hint=format(int(char_chao[key-1]),'04b')
				#print("hint\n")
				#print(hint)
				netval[o_p]=logic_func(gate_name,netval[i_p1],netval[i_p2],hint)
			else:
				netval[o_p]=logic_func(gate_name,netval[i_p1],netval[i_p2])
			netstatus[o_p]=1
			i=i+1
		else:
			#print(False)
			#taking the element to the last of the list for considering later
			temp=netarray[i]
			del(netarray[i])
			netarray.append(temp)
		#print(netarray)
		#print("netval:", netval)
		#print("netstatus:", netstatus)
	outpval=[0]*len(outpname)
	for i in range(0,len(outpname)):
		outpval[i]=netval[outpname[i]]
	#print(netval['s'])
	#print(netval['co'])
	return outpval



